(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.linqts = {})));
}(this, (function (exports) {
    /**
     * Checks if the argument passed is an object
     */
    var isObj = function (x) { return !!x && typeof x === 'object'; };
    /**
     * Determine if two objects are equal
     */

    var equal = function (a, b) { return Object.entries(a).every(function (ref) {
      var key = ref[0];
      var val = ref[1];

      return isObj(val) ? equal(b[key], val) : b[key] === val;
      }); };
    /**
     * Creates a function that negates the result of the predicate
     */

    var negate = function (predicate) { return function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return !predicate.apply(void 0, args);
     }  };
    /**
     * Comparer helpers
     */

    var composeComparers = function (previousComparer, currentComparer) { return function (a, b) { return previousComparer(a, b) || currentComparer(a, b); }; };
    var keyComparer = function (_keySelector, descending) { return function (a, b) {
      var sortKeyA = _keySelector(a);

      var sortKeyB = _keySelector(b);

      if (sortKeyA > sortKeyB) {
        return !descending ? 1 : -1;
      } else if (sortKeyA < sortKeyB) {
        return !descending ? -1 : 1;
      } else {
        return 0;
      }
    }; };

    var List = function List(elements) {
      if ( elements === void 0 ) elements = [];

      this._elements = elements;
    };
    /**
     * Adds an object to the end of the List<T>.
     */


    List.prototype.Add = function Add (element) {
      this._elements.push(element);
    };
    /**
     * Adds the elements of the specified collection to the end of the List<T>.
     */


    List.prototype.AddRange = function AddRange (elements) {
        var ref;

      (ref = this._elements).push.apply(ref, elements);
    };
    /**
     * Applies an accumulator function over a sequence.
     */


    List.prototype.Aggregate = function Aggregate (accumulator, initialValue) {
      return this._elements.reduce(accumulator, initialValue);
    };
    /**
     * Determines whether all elements of a sequence satisfy a condition.
     */


    List.prototype.All = function All (predicate) {
      return this._elements.every(predicate);
    };

    List.prototype.Any = function Any (predicate) {
      return predicate ? this._elements.some(predicate) : this._elements.length > 0;
    };

    List.prototype.Average = function Average (transform) {
      return this.Sum(transform) / this.Count(transform);
    };
    /**
     * Casts the elements of a sequence to the specified type.
     */


    List.prototype.Cast = function Cast () {
      return new List(this._elements);
    };
    /**
     * Concatenates two sequences.
     */


    List.prototype.Concat = function Concat (list) {
      return new List(this._elements.concat(list.ToArray()));
    };
    /**
     * Determines whether an element is in the List<T>.
     */


    List.prototype.Contains = function Contains (element) {
      return this._elements.some(function (x) { return x === element; });
    };

    List.prototype.Count = function Count (predicate) {
      return predicate ? this.Where(predicate).Count() : this._elements.length;
    };
    /**
     * Returns the elements of the specified sequence or the type parameter's default value
     * in a singleton collection if the sequence is empty.
     */


    List.prototype.DefaultIfEmpty = function DefaultIfEmpty (defaultValue) {
      return this.Count() ? this : new List([defaultValue]);
    };
    /**
     * Returns distinct elements from a sequence by using the default equality comparer to compare values.
     */


    List.prototype.Distinct = function Distinct () {
      return this.Where(function (value, index, iter) { return (isObj(value) ? iter.findIndex(function (obj) { return equal(obj, value); }) : iter.indexOf(value)) === index; });
    };
    /**
     * Returns distinct elements from a sequence according to specified key selector.
     */


    List.prototype.DistinctBy = function DistinctBy (keySelector) {
      var groups = this.GroupBy(keySelector);
      return Object.keys(groups).reduce(function (res, key) {
        res.Add(groups[key][0]);
        return res;
      }, new List());
    };
    /**
     * Returns the element at a specified index in a sequence.
     */


    List.prototype.ElementAt = function ElementAt (index) {
      if (index < this.Count() && index >= 0) {
        return this._elements[index];
      } else {
        var MSG = 'ArgumentOutOfRangeException: index is less than 0 or greater than or equal to the number of elements in source.';
        throw new Error(MSG);
      }
    };
    /**
     * Returns the element at a specified index in a sequence or a default value if the index is out of range.
     */


    List.prototype.ElementAtOrDefault = function ElementAtOrDefault (index) {
      return this.ElementAt(index) !== undefined && this.ElementAt(index);
    };
    /**
     * Produces the set difference of two sequences by using the default equality comparer to compare values.
     */


    List.prototype.Except = function Except (source) {
      return this.Where(function (x) { return !source.Contains(x); });
    };

    List.prototype.First = function First (predicate) {
      if (this.Count()) {
        return predicate ? this.Where(predicate).First() : this._elements[0];
      } else {
        throw new Error('InvalidOperationException: The source sequence is empty.');
      }
    };

    List.prototype.FirstOrDefault = function FirstOrDefault (predicate) {
      return this.Count(predicate) ? this.First(predicate) : undefined;
    };
    /**
     * Performs the specified action on each element of the List<T>.
     */


    List.prototype.ForEach = function ForEach (action) {
      return this._elements.forEach(action);
    };
    /**
     * Groups the elements of a sequence according to a specified key selector function.
     */


    List.prototype.GroupBy = function GroupBy (grouper, mapper) {
      var initialValue = {};

      if (!mapper) {
        mapper = function (val) { return val; };
      }

      return this.Aggregate(function (ac, v) {
        var key = grouper(v);
        var existingGroup = ac[key];
        var mappedValue = mapper(v);

        if (existingGroup) {
          existingGroup.push(mappedValue);
        } else {
          ac[key] = [mappedValue];
        }

        return ac;
      }, initialValue);
    };
    /**
     * Correlates the elements of two sequences based on equality of keys and groups the results.
     * The default equality comparer is used to compare keys.
     */


    List.prototype.GroupJoin = function GroupJoin (list, key1, key2, result) {
      return this.Select(function (x) { return result(x, list.Where(function (z) { return key1(x) === key2(z); })); });
    };
    /**
     * Returns the index of the first occurence of an element in the List.
     */


    List.prototype.IndexOf = function IndexOf (element) {
      return this._elements.indexOf(element);
    };
    /**
     * Inserts an element into the List<T> at the specified index.
     */


    List.prototype.Insert = function Insert (index, element) {
      if (index < 0 || index > this._elements.length) {
        throw new Error('Index is out of range.');
      }

      this._elements.splice(index, 0, element);
    };
    /**
     * Produces the set intersection of two sequences by using the default equality comparer to compare values.
     */


    List.prototype.Intersect = function Intersect (source) {
      return this.Where(function (x) { return source.Contains(x); });
    };
    /**
     * Correlates the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.
     */


    List.prototype.Join = function Join (list, key1, key2, result) {
      return this.SelectMany(function (x) { return list.Where(function (y) { return key2(y) === key1(x); }).Select(function (z) { return result(x, z); }); });
    };

    List.prototype.Last = function Last (predicate) {
      if (this.Count()) {
        return predicate ? this.Where(predicate).Last() : this._elements[this.Count() - 1];
      } else {
        throw Error('InvalidOperationException: The source sequence is empty.');
      }
    };

    List.prototype.LastOrDefault = function LastOrDefault (predicate) {
      return this.Count(predicate) ? this.Last(predicate) : undefined;
    };

    List.prototype.Max = function Max (selector) {
      var id = function (x) { return x; };

      return Math.max.apply(Math, this._elements.map(selector || id));
    };

    List.prototype.Min = function Min (selector) {
      var id = function (x) { return x; };

      return Math.min.apply(Math, this._elements.map(selector || id));
    };
    /**
     * Filters the elements of a sequence based on a specified type.
     */


    List.prototype.OfType = function OfType (type) {
      var typeName;

      switch (type) {
        case Number:
          typeName = typeof 0;
          break;

        case String:
          typeName = typeof '';
          break;

        case Boolean:
          typeName = typeof true;
          break;

        case Function:
          typeName = typeof function () {}; // tslint:disable-line no-empty

          break;

        default:
          typeName = null;
          break;
      }

      return typeName === null ? this.Where(function (x) { return x instanceof type; }).Cast() : this.Where(function (x) { return typeof x === typeName; }).Cast();
    };
    /**
     * Sorts the elements of a sequence in ascending order according to a key.
     */


    List.prototype.OrderBy = function OrderBy (keySelector, comparer) {
        if ( comparer === void 0 ) comparer = keyComparer(keySelector, false);

      return new OrderedList(this._elements, comparer);
    };
    /**
     * Sorts the elements of a sequence in descending order according to a key.
     */


    List.prototype.OrderByDescending = function OrderByDescending (keySelector, comparer) {
        if ( comparer === void 0 ) comparer = keyComparer(keySelector, true);

      return new OrderedList(this._elements, comparer);
    };
    /**
     * Performs a subsequent ordering of the elements in a sequence in ascending order according to a key.
     */


    List.prototype.ThenBy = function ThenBy (keySelector) {
      return this.OrderBy(keySelector);
    };
    /**
     * Performs a subsequent ordering of the elements in a sequence in descending order, according to a key.
     */


    List.prototype.ThenByDescending = function ThenByDescending (keySelector) {
      return this.OrderByDescending(keySelector);
    };
    /**
     * Removes the first occurrence of a specific object from the List<T>.
     */


    List.prototype.Remove = function Remove (element) {
      return this.IndexOf(element) !== -1 ? (this.RemoveAt(this.IndexOf(element)), true) : false;
    };
    /**
     * Removes all the elements that match the conditions defined by the specified predicate.
     */


    List.prototype.RemoveAll = function RemoveAll (predicate) {
      return this.Where(negate(predicate));
    };
    /**
     * Removes the element at the specified index of the List<T>.
     */


    List.prototype.RemoveAt = function RemoveAt (index) {
      this._elements.splice(index, 1);
    };
    /**
     * Reverses the order of the elements in the entire List<T>.
     */


    List.prototype.Reverse = function Reverse () {
      return new List(this._elements.reverse());
    };
    /**
     * Projects each element of a sequence into a new form.
     */


    List.prototype.Select = function Select (selector) {
      return new List(this._elements.map(selector));
    };
    /**
     * Projects each element of a sequence to a List<any> and flattens the resulting sequences into one sequence.
     */


    List.prototype.SelectMany = function SelectMany (selector) {
        var this$1 = this;

      return this.Aggregate(function (ac, _, i) { return (ac.AddRange(this$1.Select(selector).ElementAt(i).ToArray()), ac); }, new List());
    };
    /**
     * Determines whether two sequences are equal by comparing the elements by using the default equality comparer for their type.
     */


    List.prototype.SequenceEqual = function SequenceEqual (list) {
      return !!this._elements.reduce(function (x, y, z) { return list._elements[z] === y ? x : undefined; });
    };
    /**
     * Returns the only element of a sequence, and throws an exception if there is not exactly one element in the sequence.
     */


    List.prototype.Single = function Single (predicate) {
      if (this.Count(predicate) !== 1) {
        throw new Error('The collection does not contain exactly one element.');
      } else {
        return this.First(predicate);
      }
    };
    /**
     * Returns the only element of a sequence, or a default value if the sequence is empty;
     * this method throws an exception if there is more than one element in the sequence.
     */


    List.prototype.SingleOrDefault = function SingleOrDefault (predicate) {
      return this.Count(predicate) ? this.Single(predicate) : undefined;
    };
    /**
     * Bypasses a specified number of elements in a sequence and then returns the remaining elements.
     */


    List.prototype.Skip = function Skip (amount) {
      return new List(this._elements.slice(Math.max(0, amount)));
    };
    /**
     * Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements.
     */


    List.prototype.SkipWhile = function SkipWhile (predicate) {
        var this$1 = this;

      return this.Skip(this.Aggregate(function (ac) { return predicate(this$1.ElementAt(ac)) ? ++ac : ac; }, 0));
    };

    List.prototype.Sum = function Sum (transform) {
      return transform ? this.Select(transform).Sum() : this.Aggregate(function (ac, v) { return ac += +v; }, 0);
    };
    /**
     * Returns a specified number of contiguous elements from the start of a sequence.
     */


    List.prototype.Take = function Take (amount) {
      return new List(this._elements.slice(0, Math.max(0, amount)));
    };
    /**
     * Returns elements from a sequence as long as a specified condition is true.
     */


    List.prototype.TakeWhile = function TakeWhile (predicate) {
        var this$1 = this;

      return this.Take(this.Aggregate(function (ac) { return predicate(this$1.ElementAt(ac)) ? ++ac : ac; }, 0));
    };
    /**
     * Copies the elements of the List<T> to a new array.
     */


    List.prototype.ToArray = function ToArray () {
      return this._elements;
    };

    List.prototype.ToDictionary = function ToDictionary (key, value) {
        var this$1 = this;

      return this.Aggregate(function (dicc, v, i) {
        dicc[this$1.Select(key).ElementAt(i).toString()] = value ? this$1.Select(value).ElementAt(i) : v;
        dicc.Add({
          Key: this$1.Select(key).ElementAt(i),
          Value: value ? this$1.Select(value).ElementAt(i) : v
        });
        return dicc;
      }, new List());
    };
    /**
     * Creates a List<T> from an Enumerable.List<T>.
     */


    List.prototype.ToList = function ToList () {
      return this;
    };
    /**
     * Creates a Lookup<TKey, TElement> from an IEnumerable<T> according to specified key selector and element selector functions.
     */


    List.prototype.ToLookup = function ToLookup (keySelector, elementSelector) {
      return this.GroupBy(keySelector, elementSelector);
    };
    /**
     * Produces the set union of two sequences by using the default equality comparer.
     */


    List.prototype.Union = function Union (list) {
      return this.Concat(list).Distinct();
    };
    /**
     * Filters a sequence of values based on a predicate.
     */


    List.prototype.Where = function Where (predicate) {
      return new List(this._elements.filter(predicate));
    };
    /**
     * Applies a specified function to the corresponding elements of two sequences, producing a sequence of the results.
     */


    List.prototype.Zip = function Zip (list, result) {
        var this$1 = this;

      return list.Count() < this.Count() ? list.Select(function (x, y) { return result(this$1.ElementAt(y), x); }) : this.Select(function (x, y) { return result(x, list.ElementAt(y)); });
    };
    /**
     * Represents a sorted sequence. The methods of this class are implemented by using deferred execution.
     * The immediate return value is an object that stores all the information that is required to perform the action.
     * The query represented by this method is not executed until the object is enumerated either by
     * calling its ToDictionary, ToLookup, ToList or ToArray methods
     */


    var OrderedList = /*@__PURE__*/(function (List) {
      function OrderedList(elements, _comparer) {
        List.call(this, elements);
        this._comparer = _comparer;

        this._elements.sort(this._comparer);
      }

      if ( List ) OrderedList.__proto__ = List;
      OrderedList.prototype = Object.create( List && List.prototype );
      OrderedList.prototype.constructor = OrderedList;
      /**
       * Performs a subsequent ordering of the elements in a sequence in ascending order according to a key.
       * @override
       */


      OrderedList.prototype.ThenBy = function ThenBy (keySelector) {
        return new OrderedList(this._elements, composeComparers(this._comparer, keyComparer(keySelector, false)));
      };
      /**
       * Performs a subsequent ordering of the elements in a sequence in descending order, according to a key.
       * @override
       */


      OrderedList.prototype.ThenByDescending = function ThenByDescending (keySelector) {
        return new OrderedList(this._elements, composeComparers(this._comparer, keyComparer(keySelector, true)));
      };

      return OrderedList;
    }(List));

    var Enumerable = function Enumerable () {};

    Enumerable.Range = function Range (start, count) {
      var result = new List();

      while (count--) {
        result.Add(start++);
      }

      return result;
    };
    /**
     * Generates a sequence that contains one repeated value.
     */


    Enumerable.Repeat = function Repeat (element, count) {
      var result = new List();

      while (count--) {
        result.Add(element);
      }

      return result;
    };

    /**
     * LinQ to TypeScript
     *
     * Documentation from LinQ .NET specification (https://msdn.microsoft.com/en-us/library/system.linq.enumerable.aspx)
     *
     * Created by Flavio Corpa (@kutyel)
     * Copyright © 2016 Flavio Corpa. All rights reserved.
     *
     */

    exports.List = List;
    exports.Enumerable = Enumerable;

})));
//# sourceMappingURL=index.umd.js.map
